import { Router, Request, Response } from 'express';
import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
} from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
import { config } from '../config';

export const taskRoutes = Router();

const connection = new Connection(config.rpcUrl, 'confirmed');

// Helper to create Action response
interface ActionGetResponse {
  icon: string;
  title: string;
  description: string;
  label: string;
  links?: {
    actions: Array<{
      label: string;
      href: string;
      parameters?: Array<{
        name: string;
        label: string;
        required?: boolean;
      }>;
    }>;
  };
}

interface ActionPostResponse {
  transaction: string;
  message?: string;
}

/**
 * GET /actions/tasks/:taskPubkey
 * Returns Action metadata for a task
 */
taskRoutes.get('/:taskPubkey', async (req: Request, res: Response) => {
  try {
    const { taskPubkey } = req.params;

    // Validate pubkey
    let taskKey: PublicKey;
    try {
      taskKey = new PublicKey(taskPubkey);
    } catch {
      return res.status(400).json({ error: 'Invalid task public key' });
    }

    // In production, fetch actual task data from chain
    // For now, return placeholder metadata
    const response: ActionGetResponse = {
      icon: config.iconUrl,
      title: 'HumanRail Task',
      description: 'Complete this human verification task to earn rewards. Choose your preferred option below.',
      label: 'Complete Task',
      links: {
        actions: [
          {
            label: 'Choose Option A',
            href: `${config.baseUrl}/actions/tasks/${taskPubkey}/respond?choice=0`,
          },
          {
            label: 'Choose Option B',
            href: `${config.baseUrl}/actions/tasks/${taskPubkey}/respond?choice=1`,
          },
          {
            label: 'Claim Rewards',
            href: `${config.baseUrl}/actions/tasks/${taskPubkey}/claim`,
          },
        ],
      },
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching task:', error);
    res.status(500).json({ error: 'Failed to fetch task' });
  }
});

/**
 * POST /actions/tasks/:taskPubkey/respond
 * Submit a response to a task
 */
taskRoutes.post('/:taskPubkey/respond', async (req: Request, res: Response) => {
  try {
    const { taskPubkey } = req.params;
    const { choice } = req.query;
    const { account } = req.body;

    if (!account) {
      return res.status(400).json({ error: 'Missing account in request body' });
    }

    let taskKey: PublicKey;
    let workerKey: PublicKey;
    try {
      taskKey = new PublicKey(taskPubkey);
      workerKey = new PublicKey(account);
    } catch {
      return res.status(400).json({ error: 'Invalid public key' });
    }

    const choiceNum = parseInt(choice as string, 10) || 0;

    // Derive PDAs
    const [responsePda] = PublicKey.findProgramAddressSync(
      [Buffer.from('response'), taskKey.toBuffer(), workerKey.toBuffer()],
      config.programIds.dataBlink
    );

    const [profilePda] = PublicKey.findProgramAddressSync(
      [Buffer.from('human_profile'), workerKey.toBuffer()],
      config.programIds.humanRegistry
    );

    // Build the submit_response instruction
    // This is a simplified version - in production, use the SDK
    const instruction = new TransactionInstruction({
      programId: config.programIds.dataBlink,
      keys: [
        { pubkey: taskKey, isSigner: false, isWritable: true },
        { pubkey: responsePda, isSigner: false, isWritable: true },
        { pubkey: profilePda, isSigner: false, isWritable: false },
        { pubkey: workerKey, isSigner: true, isWritable: true },
        { pubkey: config.programIds.humanRegistry, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data: Buffer.from([
        // submit_response discriminator (would be generated by Anchor)
        0x02,
        choiceNum,
        // 32 bytes of response data (zeros for now)
        ...new Array(32).fill(0),
      ]),
    });

    // Create transaction
    const { blockhash } = await connection.getLatestBlockhash();
    const transaction = new Transaction({
      recentBlockhash: blockhash,
      feePayer: workerKey,
    }).add(instruction);

    // Serialize for return
    const serialized = transaction
      .serialize({ requireAllSignatures: false })
      .toString('base64');

    const response: ActionPostResponse = {
      transaction: serialized,
      message: `Submitting response (choice ${choiceNum}) for task`,
    };

    res.json(response);
  } catch (error) {
    console.error('Error creating response transaction:', error);
    res.status(500).json({ error: 'Failed to create transaction' });
  }
});

/**
 * POST /actions/tasks/:taskPubkey/claim
 * Claim rewards for a completed task
 */
taskRoutes.post('/:taskPubkey/claim', async (req: Request, res: Response) => {
  try {
    const { taskPubkey } = req.params;
    const { account } = req.body;

    if (!account) {
      return res.status(400).json({ error: 'Missing account in request body' });
    }

    let taskKey: PublicKey;
    let workerKey: PublicKey;
    try {
      taskKey = new PublicKey(taskPubkey);
      workerKey = new PublicKey(account);
    } catch {
      return res.status(400).json({ error: 'Invalid public key' });
    }

    // In production, fetch task to get vault and mint info
    // For now, create a placeholder transaction

    const [responsePda] = PublicKey.findProgramAddressSync(
      [Buffer.from('response'), taskKey.toBuffer(), workerKey.toBuffer()],
      config.programIds.dataBlink
    );

    const [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from('task_vault'), taskKey.toBuffer()],
      config.programIds.dataBlink
    );

    // Placeholder instruction - would need actual task data for complete implementation
    const instruction = new TransactionInstruction({
      programId: config.programIds.dataBlink,
      keys: [
        { pubkey: taskKey, isSigner: false, isWritable: false },
        { pubkey: responsePda, isSigner: false, isWritable: true },
        { pubkey: vaultPda, isSigner: false, isWritable: true },
        // Additional accounts would be needed (mint, worker token account, etc.)
        { pubkey: workerKey, isSigner: true, isWritable: true },
      ],
      data: Buffer.from([
        // claim_rewards discriminator
        0x03,
      ]),
    });

    const { blockhash } = await connection.getLatestBlockhash();
    const transaction = new Transaction({
      recentBlockhash: blockhash,
      feePayer: workerKey,
    }).add(instruction);

    const serialized = transaction
      .serialize({ requireAllSignatures: false })
      .toString('base64');

    const response: ActionPostResponse = {
      transaction: serialized,
      message: 'Claiming task rewards',
    };

    res.json(response);
  } catch (error) {
    console.error('Error creating claim transaction:', error);
    res.status(500).json({ error: 'Failed to create transaction' });
  }
});

// Handle OPTIONS for CORS preflight
taskRoutes.options('*', (req, res) => {
  res.status(200).end();
});
